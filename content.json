[{"title":"独立游戏策划开发实录","date":"2022-01-25T15:04:45.000Z","path":"2022/01/25/lsd/","text":"2022-1-25其实已经开始一段时间了，想着可以记录一下过程。先不说了，和朋友去玩Pummel Party了。 2022-2-17最近回到学校了，理一下目前游戏的进度吧。目前美术素材已经比较齐了，不管是人物立绘还是Q版，动画也完成了一些，还有场景、武器，几乎已经是要啥有啥了；游戏策划的话世界观已经完善得差不多了，前段时间已经理出了一个比较合理的剧情发展时间线了，每个人物的故事线也留下很多发展的空间，后期还可以做很多工作，但目前就是聚焦在完成一个demo的剧情版本，大约2-3小时的游戏时长，因为生产力和时间都有限；感觉游戏现在的进度不是很快，最近在想怎么把剧情的对话写好，目前的策略是先不写具体对话的台词，而是将每段对话人物的言语意图和情感、这段对话要用的道具等等列出来，然后再去写台词，初次尝试确实没啥经验，但愿之后能在不断试错中找到一个比较好的出路，现在计划是在2月底之前完成对话脚本；游戏程序开发的目前都是瑾哥在进行，用的是他自己写的开源游戏引擎Dorothy-SSR，现在已经完成了部分场景的搭建、人物的基本操作，还有一些UI界面，一直很佩服他为这个游戏所做的一切，应该是热爱吧。至于我的话也想尽快参与到开发中，但我好像一直没有迈出那一步，不知道自己是卡在哪一步了…加油吧。 2022-3-5最近试着跟着Dodothy-SSR里的几个例子初步熟悉了一下引擎的使用，了解了ECS系统、相机、物理碰撞什么的，用Yuescript写起来很方便；然后试着用xml写了游戏内一个手机界面的UI，就是把素材拼了起来，没有实际的交互，xml里面也可以内嵌Yue和Lua的代码，最后是编译成Lua代码的。后期打算用MVVM架构来写UI和数据的逻辑，会更加方便；距离比赛最后提交日还有一个月多几天，接下来一个月尽量不摸鱼了。"},{"title":"2021年度总结","date":"2021-12-31T14:29:57.000Z","path":"2021/12/31/2021-summary/","text":"2021过得有点快了，我总感觉我昨天还在玩合成大西瓜庆祝寒假开始，现在已经快要步入下一个寒假了，就趁考试周的摸鱼间隙试着写点简短的流水账总结。 一月 1.1当天一个人绕着莫愁湖逛了一圈 活着度过考试周 在摸爬滚打下建了自己的博客，注册了人生中第一个域名 第一个月过得比较五味杂陈，大半个月都在纠结疫情和被压缩的考试周（该死的疫情），当时一个礼拜要考九门，其中有四五门难啃的课，我记得倒数第二门是《计算机组成原理》，前一天晚上我在i++俱乐部的工位上 复 (自) 习 (学) 到凌晨一点，然后直接睡在那里的折叠床上了，睡醒再看一会就去考试了，考完立马就去看下一门《离散数学》了。之前对考完那个晚上还是很期待的，但是那个晚上好像并没有很开心。不过第二天就很开心了，因为可以回家了。回家的话就记得我每天睡到中午，看看视频看看剧。 二月 看完一部德剧《暗黑》 去了一次好久都没去一直都很想去的欢乐谷 换了新电脑 之前有跟爸妈说要换电脑，原本以为很难说服他们，但是他们居然很快就答应了，我也挺不好意思的，毕竟也是挺大一笔开销（不过我现在已经把这笔钱赚回来了嘿嘿），很感谢爸妈（不过也得承认有时候会觉得他们烦）。原本信誓旦旦在新电脑到了之后好好学编程知识，结果好像整个寒假就在刷剧和玩耍中度过了，和朋友在一起玩的日子总是快乐的，又短暂的，收拾收拾行李又该回学校了。 三月 继幼儿园和爸爸去过动物园后再次去了动物园，南京红山动物园 一天之内因为地图的不清楚和车技的原因开了六次长江隧道 第一次坐了摩天轮（应该是第一次吧），然后在长江边散步 剪了一个非常失败的短发 还好我这个月好好玩了一把，因为四月份几乎全月无休地在上课。冒险租了辆车就出去和朋友玩了，还是很开心的。去了红山动物园、南京眼、长江边，感受到了春天的美好，嗯。 四月 清明假期回了趟乡下的家，陪奶奶在淀山湖边散步，翻看了很多老照片 成了魔方社社长，用1500个魔方拼了一幅图 一周七天都有课，做了很多的数电实验，转专业人哭了 突然成为社长，让全是课的四月更加充实了呢。不过现在看觉得当时好像也还好，就是课多了点，感觉自己的抗压能力是有在变强的（因为我有独特的摸鱼技巧）。这个月虽然还是欠了很多ddl没做，但是五一假期就可以回家啦，所以最后几天最重要的事情就是等放假。 五月 和朋友去了烟花三月要下的扬州，很开心 在宿舍吃了非非常常辣的小龙虾拌方便面 开始学习前端，两天时间做了一个非常 简 (丑) 单(陋) 的网页聊天室（其实是作业），和同学一起coding很快乐 那天早上骑着电瓶车，扬州的雨很舒服，我记得那几天吃了很多。回了学校就是赶那些永远也做不完的ddl，其他的好像也没啥好说的，就是上课写作业睡觉，碌碌无为。噢噢对有一个得记一下，就是给法语老师做了一个简单的小视频，其实是作业啦，但我可没把它当作业看，还为最后一节课的party表演了魔方。 六月 达成了在网吧写作业的成就 喝了很多瓶热带风味冰红茶 度过了应该是最后一个有超多考试的考试周 这个月的记忆有点模糊，记得我在考试周前一周还回了一次家，然后在北理哥们的视频下欢乐地度过了考试周。 七月 在校体验了一个月暑期实训的995生活，喝了很多茶百道 加入了一个独立游戏团队，希望自己能坚持做下去 烦人的疫情让我半个月内做了八次核酸检测 买了一个乒乓拍，和朋友们打球真有意思 先是趁着考完试的那几天回了趟家，记得肯德基的鸡块很烫，回校后开启一个月的暑校（为什么要有暑校，为什么为什么为什么？）暑校后半段南京有疫情了，然后又变成线上，那天在教室里和同学一起写代码赶ddl的时候被通知下个月提前开始大三的第一学期。 八月 躺着睡着吃着外卖度过了一个月的宿舍网课 比较迷茫，每天都在期待什么时候能放假回家 回家后和朋友一起打游戏、打乒乓、吃烧烤 虽然是大三第一学期，但是几乎没有听课，上课时间不是在玩手机，就是在床上躺着。很焦虑，但是不知道在焦虑什么。秉着不想麻烦别人的奇怪原则自己一个人完成了社团的招新。回家之后火速和朋友冲向kfc、乒乓馆，然后晚上一起玩俄罗斯方块。 九月 回了自从高考之后就没有回去的高中，和Sue聊了一会儿天，然后回CAD社团兜了一圈，多了很多3D打印机，但还是那个感觉 每天都和朋友一起玩拆弹猫，太好玩了 晚上和朋友骑车三十公里去赏月，椒麻鸡和手抓羊肉饭很香 收到了很多生日礼物，吃了好几次肥猫 换了一副眼镜，烫了一次勉强满意的头 过于充实的九月，还是放假的日子最开心，这个月成了家附近一家汤包馆和烧烤店的常客；在一次小意外中了解到互相给朋友留下各自父母电话的重要性；看了《失控玩家》，感觉和自己正在策划的游戏有一点点相似。骑车那天晚上的路上上下下，哼着歌吹着风很惬意，就是那盘椒麻鸡的洋葱有点多了。上大学后难得赶上在家过生日，和爸妈出去一起吃饭，和朋友们聚了很多次，打了很多剧本杀和桌游。 十月 一个人搬运500多个魔方来回奔波完成摆摊，认识了很多热爱魔方的新生 学校解封后和舍友去了夜市，站在街边吃总是会更加好吃一点，所以吃了一口毛鸡蛋 在宿舍买了一个小锅，自己偶尔做点吃的 回到学校还是上了两个礼拜的宿舍网课，so还是没怎么听课；宿舍里多了一口锅和一个小冰箱；在和魔方社新生的交流中逐渐找到了初中时玩魔方的热情，魔友总是会有种神秘的力量。 十一月 去了在钟山脚下的海底世界，看了IMAX版的《沙丘》 在学校食堂吃到了火锅，和同学聊得很开心 买了自己的第一台微单相机，试着入门摄影 拉了老友一起策划游戏剧情，非常快乐 写了很多代码，做了好几个小项目 突然发现自己好像可以经济独立了，希望以后也能保持 用宿舍的锅煮了水饺，学校超市的速冻水饺很难吃；因为帮《最强大脑》写了一个3D魔方的小程序而成为了录制人员之一，估计之后可以去录制现场瞅一眼。双十一的时候狠狠消费了一把，买了一把键盘、一件毛衣、一个包。这个月和同学约了很多次乒乓，每次打完就去食堂吃夜宵，然后谈天说地聊到食堂关门。在i++窗子里装了两颗被秋风完全吹黄但是没掉叶子的银杏树，被美到了。学校食堂的火锅也还行，比外面便宜，量还比较多。买了一个ps4手柄，玩了一下午的《晶体管》，美术和配乐都很赞，寒假有时间继续玩。这个月吃了很多炒饭，最喜欢“酸豆角鸡蛋炒饭加个蛋在这吃”。 十二月 继19年末的徐州赛后终于参加了一场魔方比赛，拍了一个6秒很开心 和同学一起喝了很多啤酒，去了一次ktv，在外面吃了好几顿 狂赶十几份课程报告和大作业，精神归西，只想多眯 试图在三四天之内补完落下的课业顺带复习考试 在2021年的倒数第二天以最快速度冲上栖霞山拍到了日落的尾巴 这个月好像有点浪，但我发现自己逐渐好像可以应付焦虑了，感觉可能是找到了自己以后的生活方向了。每次去魔方比赛总是会认识一些新魔友，并且见到很久没见的老魔友，只要在一起玩魔方，我们就能聊一整天。和同学一起赶ddl的日子还是痛并快乐的，一起挤在食堂的小沙发上，吃着kfc。在临近考试的时候才发现自己这个学期好像根本就没有认真听过课，几乎每节课都在干自己想干的事，比如睡觉和写代码，所以到了考试前才知道自己完了，不过好在第一门是开卷考，第二门感觉也能比较轻松应对，所以复习也就划水过去了。第二门考完是30号中午，直接和同学冲出校门吃了今年最后一次疯四和三年没吃的章鱼小丸子，傍晚登上了一路都没有灯的栖霞山，在路上还遇到了野猪。跨年的晚上点了一个披萨在宿舍，写着年度总结。感觉今年的上半年是迷茫的，下半年是酣畅的，失去了一些，但得到了更多。"},{"title":"数据库原理复习（考前救急专用）","date":"2021-12-25T06:30:06.000Z","path":"2021/12/25/db_review/","text":"Chapter 1 数据库系统引论简介主要参考的是王能斌老师编写的《数据库系统教程》第二版上册，每个标题旁边是对应书上的页码。 可恶啊，这学期数据库没怎么听课，还有三天就期末考了，我能补回来吗？ 数据库基本概念 P2-5数据库：A very large, integrated collection of data. DBMS：A software package designed to store and manage databases. 文件系统vs数据库 应用程序需要在主存和外存中存储大量数据 对不同的查询有专属的代码 确保数据不会因为多并发用户而产生不一致性 对于崩溃的恢复 安全和访问的控制 数据库系统特点：P6-7 数据库三级模式与两级数据独立性 P 7-9 数据(Data)：对事物描述的符号记录 数据模型(Data Model)：用来描述数据的一组概念和定义 数据模式(Data Schema)：对某一类数据的结构、联系和约束的描述 应用程序应该独立于数据是如何组织和存储的 逻辑独立性：Protection from changes in logical structure of data. 物理独立性：Protection from changes in physical structure of data. 数据库系统的组成与生命期 P10 组成 生命周期 数据库系统规划 数据库设计 数据库建立 数据库运行、管理和维护 数据库的扩充和重构 Chapter 2 数据模型层次数据模型 P12-17 Basic idea: 记录（record）和字段（field） Parent-Child relationship 虚拟记录 大量指针增加数据库开销，数据模式不够清晰、直观 网状数据模型 P17-21 Basic idea: 记录和数据项（data items） 系（set） 关系数据模型（重划点）P21-25 基本数据结构：表（或者说是一种关系），可以用严格的数学方法来研究。 软连接： 关系 相当于一个表（table），包含多个元组 关系R的schema：$R=(A_{1}, A_{2},…,A_{n})$，其中A是属性名，n为关系的目（degree）。 键 候选键（candidate key）可以由一个或多个属性构成，简称键。 至少一个候选键，选择一个作为主键（primarykey），其他候选键为补键（alternate key） 超键（super key），至少包含一个键的属性组（{学号、出生年月}） 全键（all key），主键由所有属性构成 主属性和非主属性 外键（foreign key），一个逻辑指针，指向另一个表中的元组 完整性约束：语意施加在数据上的限制（只有在数据库更新是检查完整性约束） 域完整性约束：在域中 实体完整性约束：有不为空的主键 引用完整性约束：对应外键的元组相等或不存在 一般性完整性约束：所有约束 关系代数（Realtional Algebra）P25-29 选择操作（selection）：选取某些行 投影操作（projection）：选取某些列（产生重复元组） 集合操作（cross-product）：并、差、交（要满足并兼容，目、域都相同） 笛卡尔乘积（不必并兼容）：所有元组各种可能的组合 连接操作（join operation）：只连接满足条件的，没有条件的话就是笛卡尔（如不说明，就是自然连接，会消除冗余的等连接） 除操作（division）： 外连接（outer join）：左，右，全 与连接的区别在于外连接会保留非匹配元组，空缺部分填NULL 外并（outer union）：不用并兼容，无属性的话补NULL 关系演算（Relational Calculus）P29-30 元组关系演算（Tuple Relational Calculus） 域关系演算（Domain Relational Calculus） 传统数据模型评价 P30-33 层次、网状、关系数据模型都是传统数据模型 适用于OLTP(On-Line Transaction Processing) 以记录为基础，不能更好的面向用户和应用 不能用一种很自然的模式表达实体之间的关系 缺少语义信息 数据类型少，很难满足应用的需求 ER数据模型和面向对象数据模型 P33-44 ER实体：现实世界中可以和其他物体区分的物体，用一组属性来描述 实体集（Entity Set）：相似实体的集合（例子：所有员工） ER图P37-39 弱实体（不能单独存在） 特殊化和普遍化 聚集 范畴 （这部分应该不会考很多吧，我就先不看了） 今天又摸了半天鱼，晚安 Chapter 3 数据库语言SQLSQL简介 P56-57 Structured Query Language(or Standard Query Language) 一种非过程语言，用户不需要说明如何获取数据，而只用说需要什么数据 四个功能 用来定义、删除或者改变数据模式（Data Definition Language） 用来取数据（Query language）本章重点 用来插入、删除或者更新数据（Data Manipulation Language）本章重点 用来控制用户访问数据的权限（Data Control Language） 基本概念 基表：数据显示地存在数据库中 视图：虚表 查询语言查询语句基本结构 P62-63SELECT [DISTINCT] target-list //DISTINCT，消除重复元组 FROM relation-list //关系列表 WHERE qualification //条件 执行顺序： FROM WHERE GROUP BY HAVING SELECT ORDER BY（重要！） 简单查询语句 P63-64 后面的例子需要用到的表 范围变量（Range Variables）AS 就是给FROM后的表取别名 //正常写法 SELECT sname FROM Sailors, Reserves WHERE Sailors.sid=Reserves.sid AND bid=103 //取别名 SELECT S.sname FROM Sailors S, Reserves R WHERE S.sid=R.sid AND bid=103 使用表达式 = AS LIKE SELECT S.age, age1=S.age-5, 2*S.age AS age2 //AS和’=‘一样， FROM Sailors S WHERE S.sname LIKE ‘B_%B’ //'_'表示任意一个字符，'%'表示零个及以上个任意字符 基于集合操作的查询语句 P69 用集合的并集和交集 UNION 相当于OR UNION ALL 表示将所有元组并起来，包括那些重复项，UNION则会去除重复项 //找出预定过红船或绿船的水手 SELECT S.sid FROM Sailors S, Boats B, Reserves R WHERE S.sid=R.sid AND R.bid=B.bid AND B.color=‘red’ UNION SELECT S.sid FROM Sailors S, Boats B, Reserves R WHERE S.sid=R.sid AND R.bid=B.bid AND B.color=‘green’ SELECT S.sid FROM Sailors S,Boats B,Reserves R WHERE S.sid=R.sid AND R.bid=B.bid AND (B.color=‘red’ OR B.color=‘green’) INTERSECT 相当于 AND //找出同时预定红船和绿船的水手 SELECT S.sid FROM Sailors S, Boats B, Reserves R WHERE S.sid=R.sid AND R.bid=B.bid AND B.color=‘red’ INTERSECT SELECT S.sid FROM Sailors S, Boats B, Reserves R WHERE S.sid=R.sid AND R.bid=B.bidAND B.color=‘green’ SELECT S.sid FROM Sailors S, Boats B1, Reserves R1, Boats B2, Reserves R2 WHERE S.sid=R1.sid AND R1.bid=B1.bid AND S.sid=R2.sid AND R2.bid=B2.bid AND (B1.color=‘red’ AND B2.color=‘green’) 基于嵌套子查询的查询语句 P66-67 Nested Queries 就是在FROM WHERE SELECT 中也可以用sql查询 IN NOT IN //查找预定过103号船的水手，如果用`NOT IN`就表示没预定过103 SELECT S.sname FROM SailorsS WHERE S.sid IN (SELECT R.sid //意思是这个值在选出来的表中 FROM ReservesR WHERE R.bid=103) // `(NOT)IN` 也可以用 `(NOT)EXISTS`代替，写法略有不同 SELECT S.sname FROM Sailors S WHERE EXISTS (SELECT * //意思应该是存在这样的元组 FROM ReservesR WHERE R.bid=103 AND S.sid=R.sid) //如果要查找只预定过一次103这艘船的水手名字呢？ SELECT S.sname FROM Sailors S WHERE EXISTS (SELECT * FROM Reserves R WHERE R.bid=103 AND S.sid=R.sid) NOT EXISTS (SELECT * FROM Reserves R1, Reserves R2) WHERE ... AND R1.day != R2.day //查找只被一个水手预定过的船的bid SELECT bid FROM Reserves R1 WHERE bid NOT IN (SELECT bid //被其他水手订过的船的bid FROM Reserves R2 WHERE R2.sid ¬= R1.sid) op ANY op ALL //找到一个水手比至少一个叫Horatio的水手评分高的（只要比一个高就行） SELECT * FROM SailorsS WHERE S.rating>ANY (SELECT S2.rating FROM SailorsS2 WHERE S2.sname=‘Horatio’) 除法与聚集函数计算 P66 Division //查找那些预定过所有船的水手 SELECT S.sname FROM Sailors S WHERE NOT EXISTS //不存在没有预定的船 ((SELECT B.bid FROM Boats B) EXCEPT //排除那些已经有人预定过的船的bid (SELECT R.bid FROM Reserves R WHERE R.sid=S.sid)) Aggregate Operators COUNTS(*)：统计找到的元组总数 COUNT([DISTINCT] A)：返回不重复的属性A的值有多少个 SUM([DISTINCT] A)：返回不重复的属性A的值总和 AVG([DISTINCT] A)：返回不重复的属性A的值平均值 MAX(A)：属性A所有值中的最大值 MIN(A)：属性A所有值中的最小值 SELECT COUNT (*) //所有的元组 FROM SailorsS SELECT AVG (S.age) //评分为10的水手平均年龄 FROM SailorsS WHERE S.rating=10 SELECT COUNT (DISTINCT S.rating) //叫Bob的有多少种评分 FROM SailorsS WHERE S.sname=‘Bob’ SELECT AVG (DISTINCT S.age) //评分为10的有几种年龄 FROM SailorsS WHERE S.rating=10 SELECT S.sname //评分最高的水手名字 FROM SailorsS WHERE S.rating= (SELECT MAX(S2.rating) FROM SailorsS2) 分组聚集函数计算 P68-69 为什么分组 例子：要找到每种评分中最年轻的水手（不知道有几种评分） GROUP BY HAVING 通常会和聚集函数一起用 按列的值分组，一样的分在一组 SELECT [DISTINCT] target-list FROM relation-list WHERE qualification GROUP BY grouping-list HAVING group-qualification //属性必须是grouping-list的子集，不然语法报错 例子： //找到年龄大于18的最年轻水手的年纪，并且这个水手的评分必须至少还有一人和他一样 SELECT S.rating, MIN (S.age) AS minage //SELECT最后执行 FROM SailorsS WHERE S.age >= 18 GROUP BY S.rating HAVING COUNT (*) > 1 //HAVING COUNT (*) > 1 AND EVERY (S.age &lt;=60)表示组内水手必须满足所有人年龄小于60 //找到每艘红船的预定数量 SELECT B.bid, COUNT (*) AS scount //3. 再统计每组的数量 FROM Boats B,Reserves R WHERE R.bid=B.bid AND B.color=‘red’ //1. 先找到红船 GROUP BY B.bid //2.然后分组 聚集函数不能嵌套使用 例子 //找到平均年龄最小的评分 SELECT S.rating FROM Sailors S WHERE S.age = (SELECT MIN (AVG (S2.age)) //错误！！！ FROM Sailors S2) //改正 SELECT Temp.rating FROM (SELECT S.rating, AVG (S.age) AS avgage //2.再取每个组内的平均值 FROM SailorsS GROUP BY S.rating) AS Temp //1.先按评分分组 WHERE Temp.avgage = (SELECT MIN (Temp.avgage) //3.取平均值值最小的 FROM Temp) fuck 今天是一点不想复习啊 CAST与CASE表达式 CAST 强制数据类型转换 SELECT name, school, CAST(NULL AS Varchar(20)) FROM Students CASE 跟在SELECT后面 //Officers (name, status, rank, title) SELECT name, CASE status WHEN 1 THEN ‘Active Duty’ WHEN 2 THEN ‘Reserve’ WHEN 3 THEN ‘Special Assignment’ WHEN 4 THEN ‘Retired’ ELSE ‘Unknown’ END AS status FROM Officers 标量子查询 dept(deptno, deptname, location) emp(deptno, salary, bonus) 就是这个子查询只会返回一个元组 //找到那些平均奖金高于平均工资的部门 SELECT d.deptname, d.location FROM dept AS d WHERE (SELECT avg(bonus) FORM emp WHERE deptno=d.deptno) > (SELECT avg(salary) FORM emp WHERE deptno=d.deptno) 表表达式与公共表表达式 Table Expression 就是说会返回一个表 找到那些总支出大于200000的部门们 SELECT deptno, totalpay FROM (SELECT deptno, sum(salay)+sum(bonus) AS totalpay FROM emp GROUP BY deptno) AS payroll WHERE totalpay>200000; Common Table Expression 用WITH创建一个临时表相当于 //找到总支出最大的部门 WITH payroll (deptno, totalpay) AS (SELECT deptno, sum(salary)+sum(bonus) FROM emp GROUP BY deptno) SELECT deptno FROM payroll WHERE totalpay = (SELECT max(totalpay) FROM payroll); 递归子查询//找到所有上司是Hoover的员工，并且他们的薪水都高于100000 WITH agents (name, salary) AS ((SELECT name, salary --initial query FROM FedEmp WHERE manager=‘Hoover’) UNION ALL (SELECT f.name, f.salary --recursive query FROM agents AS a, FedEmp AS f WHERE f.manager = a.name)) SELECT name --final query FROM agents WHERE salary>100000 ; //一个比较复杂的例子 WITH trips (destination, route, nsegs, totalcost) AS ((SELECT destination, CAST(destination AS varchar(20)), 1, cost FROM flights --- initial query WHERE origin=‘SFO’) UNION ALL (SELECT f.destination, --- recursive query CAST(t.route||’,’||f.destination AS varchar(20)), t.nsegs+1, t.totalcost+f.cost FROM trips t, flights f WHERE t.destination=f.origin AND f.destination&lt;>’SFO’ --- stopping rule 1 AND f.origin&lt;>’JFK’ --- stopping rule 2 AND t.nsegs&lt;=3)) --- stopping rule 3 SELECT route, totalcost --- final query FROM trips WHERE destination=‘JFK’ AND totalcost= --- lowest cost rule （SELECT min(totalcost) FROM trips WHERE destination='JFK') 数据操纵语言 P69-71 INSERT INSERT INTO EMPLOYEES VALUES ('Smith', 'John', '1980-06-10', 'Los Angles', 16, 45000); DELETE DELETE FROM Person WHERE LastName = 'Rasmussen' ; UPDATE UPDATE Person SET Address = 'Zhongshan 23', City = 'Nanjing' WHERE LastName = 'Wilson'; 关于视图 P72-75 普通视图 临时视图和递归查询 嵌入式SQL P75-79 为了直接在其他编程语言中直接访问数据库 以EXEC SQL开头，;结尾 通过宿主变量（host variables）与程序交流，在SQL语句中宿主变量前面必须加:；只能是一般变量，不能是数组或者其他结构 //定义宿主变量 EXEC SQL BEGIN DECLARE SECTION; char SNO[7]; char GIVENSNO[7]; char CNO[6]; char GIVENCNO[6]; float GRADE; short GRADEI; /*indicator of GRADE，为负数则表示GRADE为NULL*/ EXEC SQL END DECLARE SECTION; 特殊的宿主变量SQLCA,通常用SQLCA.SQLCODE来表示SQL执行结果 &lt;0表示出错且未执行 =0表示正常 &gt;0表示已执行，但有异常 =100表示无数据可取，通常是数据取完了 CONNECT EXEC SQL CONNECT :uid IDENTIFIED BY :pwd; 执行查询或者操作 EXEC SQL INSERT INTO SC(SNO,CNO,GRADE) VALUES(:SNO, :CNO, :GRADE); EXEC SQL SELECT GRADE INTO :GRADE :GRADEI //因为只能查到一个值，所以可以直接赋值 FROM SC WHERE SNO=:GIVENSNO AND CNO=:GIVENCNO; CURSOR 可以将多个查到的值放入数组 EXEC SQL INCLUDE SQLCA EXEC SQL BEGIN DECLARE SECTION; char sname[20]; EXEC SQL END DECLARE SECTION; EXEC SQL DECLARE student-cursor CURSOR FOR --Step1：声明游标 SELECT S.sname FROM student S WHERE S.gpa>3.5 EXEC SQL OPEN student-cursor; --Step2：打开游标 while(TRUE) &#123; EXEC SQL FETCH C1 INTO :sname; --Step3: 读数据 if(SQLCA.SQLCODE==100) --读完了 break; if(SQLCA.SQLCODE&lt;0) --出错了 break; /* ...处理游标中所取的数据 */ printf(\"%s\\n\", sname); &#125;; EXEC SQL CLOSE C1; --Step4：关闭游标 动态SQL与存储过程 P79-82考到了就现学 Chapter 4 数据库管理系统DBMS核心的模块结构 P88-90 用户写的应用程序经过接口转为基础的数据库语言（SQL等） SQL经过词法及语法分析产生语法树 之后检查用户是否有权访问语法树涉及的数据对象，若通过则继续执行，否则拒绝执行 授权检查通过后，进行语义分析与处理，对四种语言分别做不同处理（通常统称为查询处理），其中QL最复杂也最基本，存在多种存取路径选择问题（查询优化） 后就形成SQL语句执行 DLL： 存放SQL的动态链接库 并发控制： SQL语句执行过程都有并发控制以防止多用户并发访问数据引起数据不一致 恢复机制：发生故障时，能使数据库恢复到最近的一致状态或先前的某个一致状态 DBMS是操作系统之上的软件系统，是操作系统的用户,它对系统资源的调用需要请求操作系统为其服务，通过系统调用来实现 事务：DBMS的执行单位 P89-90 ACID准则 DBMS进程结构 单进程结构 程进的一单个一是就后行运，起一在接连码代心核 和码代的序程用应把 多进程结构 一个应用对应一个DBMS进程 一个应用对应一个 DBMS的一个线程 数据库访问管理 P101-111 访问类型 查询一个文件的全部或大部分记录(&gt;15%) 查询某一条特定记录 查询某些记录(&lt;15%) 范围查询 记录的更新 文件管理 堆文件 记录按插入顺序存放，就像堆货物一样。物理地址不一定连续，逻辑地址连续。插入容易，查找难，只能顺序搜索，删除麻烦，一般不在物理上删除，只是打删除标志，以免引起大量记录转移。 直接文件 将记录某一属性（一般为主键）用散列函数映射成记录的地址。按散列键访问快，但不同散列键可能映射同一地址，且只对散列键到记录的访问有效，键映射空间固定，不变处理变长记录，用得少 索引文件 索引+堆文件/簇集 在记录的某一属性（组）上建立索引，索引项由索引键的值及其对应的记录的地址货地址集组成。 提高查询效率，增加索引维护开销，付出储存空间代价 索引 B+树（最常用） Clustering index（常用） 倒排文件 动态hash 栅格结构文件 查询优化 代数优化（粗糙的优化） 对查询进行等效变化，以减少执行的开销 先一元操作，后二元操作，可以提取一些公共操作 操作优化（优化的重点） 合理选择存取路径 选择、投影、集合、连接、组合操作的优化 主要是连接操作的优化，因为开销最大 嵌套循环法 R为外关系，共bRb_Rb**R条记录，S为内关系，共bSb_Sb**S条记录,R每次I/O取出的为缓冲块大小的元组个数，设有nBn_Bn**B个缓冲块,一块用于内关系缓冲，其余用于外关系缓冲,则共需访问物理块数,从公式可以看出要想减少I/O次数，应该让小关系作为内关系，因为它前面有个乘数。 为什么缓存块都给外缓冲？ 因为，内关系的扫描次数取决于外关系分多少次取完，外关系每次取的越多，则内关系一次扫描所比较的元组也越多。而内关系每次扫描都要I/O整个表，而总的I/O次数中外关系的I/O次数是定值（它只用扫描一次），内关系的I/O次数只取决于其扫描次数↣\\rightarrowtail↣其扫描次数只取决于外关系取的次数↣\\rightarrowtail↣外关系取的次数取决于每次取多少，所以增大外缓冲能有效减小内关系扫描次数。 利用索引或散列寻找匹配元组法 排序归并法 散列连接法 恢复机制 减少可能出现的错误 从错误中恢复 周期性转储 每隔一段时间将磁盘数据转储到磁带（不受系统故障影响）上 转储采用增量转储 只能恢复到最近一次备份 备份+日志 日志（Log）：记录上次备份以来所有数据库的改变 前像（Before Image） 事务更新时所涉及物理块更新前的映像；有前像可使数据库回到更新前状态，即撤销更新undo,满足幂等性,就是无论undo几次都和undo一次的效果一样 后像（A.I） 事务更新时所涉及物理块更新后的映像；有后像即时更新数据丢失，仍可恢复到更新后状态，叫重做redo,也满足幂等性 事务状态：两种,commit了，说明事务已成功执行(all)；事务失败，则要消除事务对数据库影响(nothing)，叫卷回(abort/rollback) 数据库失效时，可取出最近副本，再根据运行记录 对已提交的事务用后像重做，叫向前恢复 对未提交的事务用前像卷回，叫向后恢复 这样可使数据库恢复至最近的一致状态 数据结构 Commit list ：所有已经提交的事物列表 Active list：当前在运行的、还没有提交的事物的标识符（TID） Log 提交规则 A.I必须在commit之前就写入硬盘 日志提前规则 若A.I在事务提交之前写入数据库，必须先把B.I先写入Log 幂等性 redo和undo做几次都效果一样 三种更新策略 A.I在事务提交之前写入DB： TID写入active list B.I写入日志[Log Ahead Rule] A.I写入DB [Commit Rule] TID写入commit list 在active list中删去TID A.I在事务提交之后写入DB： （流行的用法） TID进入active list A.I写入log[Commit Rule] TID写入commit list A.I写入DB 在active list中删去TID A.I写入DB与commit并发进行： TID进入active list A.I和B.I写入log[Two Rules] A.I写入DB(partially done) TID写入commit list A.I写入DB(completed) 在active list中删去TID 并发控制 P148-153 并发的问题 丢失更新（write-write conflict） 读脏数据（read-write conflict） 读值不可复现 加锁协议 2PL(two phase locking): 释放锁在所有加锁之后 well-formed:遵循先加锁，后操作 X锁（排他性） \\ NL X NL Y Y X Y N (S,X)锁，S用于读，X用于写 \\ NL s x NL Y Y Y S Y Y N X Y N N (S,U,X锁)，S用于读，U锁一般先申请，然后去更新数据，在最后写入阶段再去申请X锁，X用于写 \\ NL S u x NL Y Y Y Y S Y N Y N U Y Y N N X Y N N N 死锁与活锁 P156-159 死锁：循环等待，没有事务可以得到需要的资源来完成事务 处理：预防&amp;解决 检测死锁： 超时法：超过某一时限，则认为发生死锁 等待图法：出现回路则有死锁 防止死锁 与操作系统类似的方法 将数据对象按序编号，按序申请 当事务申请锁未获准时不是一律等待，而是让一些事务卷回重执(retry),以避免循环等待。为区别事务开始执行的先后，给他们一个随时间增长的时间标记ts(time stamp) 事务重执有两种策略 死亡-等待wait-die:年老的等年轻的事务,年轻的来了，则重执，一直到自己变得年老而等待 击伤-等待wound-die:年轻的等年老的，年老的来了，把年轻的击败，年轻的重执时直接等待 活锁：别的事务一直占用资源，低优先级的一直拿不到资源 处理：FIFO Chapter 5 数据库的安全与完整性约束数据库的安全 利用视图和查询修改 访问控制（对用户进行分类来给不同的权限 ） 普通用户 DBA 有资源特权的用户 用户标识和用户认证 通过password进行用户认证 特殊的物品，如钥匙. IC卡等等 授权 Role角色机制（通过该方法提高权限控制） 数据加密 加密后存储【密码学】，但是加密解密影响效率 审计追踪 结合数据库日志，可以在关注的对象上添加审计追踪，会记录该对象上进行的操作 完整性约束 完整性约束就是规则，一张表内所有元组都要满足的条件就是完整性约束 完整性约束的分类 静态约束 固有约束：数据模型固有的约束，如关系属性应该是原子的,即第一范式 隐含约束：数据库表的模式定义里面的约束,一般用DDL语句说明，如：域约束、实体完整性约束、外键约束【引用完整性约束】 显式约束：书p181,没解释清 动态约束 数据库在状态转换中要满足的约束叫做动态约束(可以和触发器联系) 完整性约束的说明 用过程说明：把约束的说明和检验交给应用程序 用断言说明：断言指数据库状态必须满足的逻辑条件 在基表定义中加入CHECK子句约束 用触发子表示约束,下小节细讲 CREATE TABLE Sailors( sid INTEGER, sname CHAR(10), rating INTEGER, age REAL, PRIMARY KEY(sid), CHECK(rating>=1 AND rating&lt;=10)); CREATE TABLE Sailors ( sid INTEGER, sname CHAR(10), age REAL, PRIMARY KEY(sid), CHECK( (SELECT COUNT(S.sid) FROM Sailors S) +(SELECT COUNT(B.bid) FROM Boats B)&lt;100) 触发器 主动数据库：能对数据库采取一些主动的动作。 数据库的主动依赖于规则 规则：ECA规则，E为事件、C为条件、A为动作。 即当事件E发生，且条件C满足时，采取A动作 //在往水手表中插入水手时，若年龄小于18则插入年轻水手表 CREATE TRIGGER youngSailorUpdate --声明触发器 AFTER INSERT ON SALORS --Event REFERENCING NEW TABLE NewSailors --对水手表新插入的元组看成一张表 FOR EACH STATEMENT --触发行为 INSERT INTO YoungSailor(sid, name, age, rating) SELECT sid, name, age, rating FROM NewSailors N WHERE N.age &lt;=18 触发器的执行策略 立即执行【常用】 当事件发生时立刻去检查条件是否满足 延迟执行 等事务要提交时执行 分离执行 把ECA规则中的动作单独作为一个事务，作为原来事务的衍生事务 Chapter 6 数据库设计数据依赖 函数依赖FD 一个属性的值可以决定其他属性的值 多值依赖MVD 一个属性的值可以决定其他一组值 连接依赖JD the constraint of lossless join decomposition. 关系模式的规范化 1NF 一范式 关系的属性必须是原子的（意思应该就不能是对象或数组这种） 2NF 二范式 满足一范式 在属性之间没有部分的函数依赖 例子： S(S#, SNAME, AGE, ADDR, C#, GRADE) 不满足2NF，因为知道S#后后面三个值能就确定了 改正：S(S#, SNAME, AGE, ADDR)和SC(S#, C#, GRADE) 不满足2范式容易出现的问题： 插入异常 上例中，不能插入一个还未选课的学生的信息 删除异常 上例中，如果一个学生申请休学，把选过的课退了，那么他的信息也会被删除 更新异常 更新中难以保持数据的一致性，上例的设计有大量的数据冗余 解决方法 设计时，一视一地。 一张表只管一件事情 3NF 三范式 满足二范式 不存在属性对主键的传递依赖 例子 ：若属性由（职工编号、工资级别、工资）三个属性组成，其中（职工编号）为主键。 分析：工资取决于工资级别，取决于职工编号 上例不满足3范式的问题 插入异常：当一个人的工资级别还没定的时候，他对应的工资也没有 删除异常：若只是删除一个员工的工资信息时，会把对应的工资级别信息也删除了 更新异常：数据内有大量的冗余 解决方法 设计时，一视一地。 一张表只管一件事情 4NF 四范式 在满足三范式的前提下，消除多值依赖。 5NF 五范式 在满足四范式的前提下，消除连接依赖。 ## 数据库设计方法 面向过程的方法 根据单位日常处理的流程，以过程为中心。 好处 在设计初期，能比较快的实现 缺点 没分析数据之间的关系，数据由冗余和矛盾，当流程进行改动时，会有很多问题 面向对象的方法 以数据为中心的方法 分析数据之间的关系，设计一些符合3NF的模式 数据库设计流程 需求分析，与用户交流确定需求 概念设计，分析数据之间的关系、实体及实体间的逻辑 逻辑设计，看采用的数据库系统，生成基表 物理设计，考虑数据在内存上到底如何存储 各阶段主要工作 需求分析 数据字典 把所有的基本数据元素都找出来 解决问题： 名字冲突：同名异意 概念冲突 域冲突 编码问题 压缩信息 基本信息 实体识别 概念设计 用ER图抽象出实体 哪些数据项抽象成实体 实体间的联系 相关ER图工具 逻辑设计 把ER图表达的数据模型进行建表 表和属性的命名规则 逆规范化 定义视图 考虑遗留系统的表的设计 物理设计 根据DBMS特点对每个表的存储和索引情况进行权衡 分区设计 总结 仅仅在结构上满足3范式是不够的 一事一地包括每项信息的唯一，要提取出问题的本质，识别本质上同一概念的信息项 对于表达类似信息、能合并尽量合并 考虑到效率、用途等因素、该分开的要分开 结合DBMS内部实现技术，合理设计索引和文件结构，为查询优化准备号存取路径 在结构规范化、减少数据冗余和提高数据库访问性能之间仔细权衡，适当折中 （勉强整理完了）"},{"title":"读书(随缘)打卡贴","date":"2021-03-05T12:47:43.000Z","path":"2021/03/05/reading_record/","text":"最近感觉得看点 技术书 书了，那就从这本 OSC 开始吧，正好最近也在上操作系统，但愿我能坚持看下去（至少看完大部分吧 2021 3.5OSC 1.1&amp;1.2 打卡 3.10OSC 1.3-1.8 打卡 感觉看英文书好难抓住重点啊 4.2OSC 3.1-3.3 打卡 4.13啊啊啊啊啊啊啊 4.25OSC 3.4-3.7 4.26OSC 4.1-4.8 5.1-5.4 4.276.1-6.8 8.13osc 当时看到了十四章就没往后看了，其实也都是大概浏览一遍（应付考试） 最近在看《硅谷之火》，讲的是个人计算机发展史（一群人在车库里改变世界的故事），据说雷军就是看了这本之后有了创业的想法。"},{"title":"日常记录贴","date":"2021-03-04T04:59:33.000Z","path":"2021/03/04/daily_record/","text":"20213.5 课好多啊啊啊啊啊啊。 3.6不可能永远都做对的，但要保持反思。 周日上一下午的课也太困了吧🥱 3.9下午在床上看个剧，暗黑太绝了 3.10Insta360 GO2 种草了种草了 3.20今天突发奇想租了辆车 跨过长江去找了雅马哈 然后去了红山森林动物园（一家没有动物表演的动物园） 以后去市区绝不开车，停车场找了半个小时 然后晚上去了南京眼 3.28最近感觉一下子多了好多事啊 不过这个周末超开心的，有个sg来南京找我 又去了趟红山动物园和南京眼，还去看了长江 4.2明天回家咯！ 4.7写作业写作业写作业！ 敲代码敲代码敲代码！ never tmr！ 4.13感觉今年的春天是一夜之间突然发生的。 4.22才发现我已经连续上了17天课了，很好，坚持到12周，每个礼拜就可以休息一天啦（指周三）。 这周老师突然又加了个数电实验，写了十几页 预 习 报告 5.5这三天去了扬州玩，吃了好多好多好多包子。 8.13感觉这段时间的自己确实有点问题，整天胡思乱想些有的没的，经历了太多魔幻的事情，有那么一丢丢麻木。但是我还是好想回家啊，都八月了，别人暑假都快结束了，我的暑假还没开始就结束了，直接变成大三了。 12.25这学期和上课沾边的事是一点没干，不过学了很多（？） 临近期末才发觉课业拉下太多，这几天努努力（叹气） 12.27发现自己好像已经很久没有把一件事情做好了，不管是什么事情，要么半途而废，要么潦草地糊过去…感觉自己还是太浮躁了，什么都想做，但目前情况下什么都做不好。 20221.10Farewell buddy. 1.13感觉自己最近消费欲望好重啊，刚花了小几千布置自己房间，现在又想自己装PC来打游戏，明明自己还没没赚什么大钱。 1.18买了一台switch。 1.21刚在洗澡的时候想了一下这一年要干啥，准确来说是这半年，其实就是立flag。 和伙伴一起完成一个独立游戏，顺便参加一些独立游戏比赛 准备面试，尽量拿到自己想要的实习offer 保持学习，开始做点简单的开源项目（最近稍微领略了一些开源的魅力） 多出去走走学学摄影，多玩玩游戏，多和朋友一起耍，多运动 有人说flag不能说出来才能实现，确实，我挺赞同这个说法，因为在说下flag的那个时候，更多的是那一刻自己很厉害的错觉，后面做不做是另外一回事。但我还是要为我这次立flag找点借口，第一我已经开始做了，第二这里肯定没多少人看得到或者说这个flag就是立给我自己看的。So，just do what excites. 3.10又到了一年几度感慨自己人生有多失败的时候了…"},{"title":"Cinema4D初体验","date":"2021-02-09T16:14:15.000Z","path":"2021/02/10/c4d_blog/","text":"​ ​ 最近在做一个unity的VR项目，需要一些3D模型，所以高中玩过三年3D打印的我自然是想着自己做啦（自信），其实是因为网上能找的好看的素材都太贵了… 以前有用过3D建模的软件，用的是Autodesk的inventor，是比较容易上手的，当初其实也就学了个皮毛，会做一点简单的3D的模型；最近正好手头项目有这个需求，又有一个朋友找我做一个模型，加上前段时间又萌生了自己捣鼓一台3D打印机的想法，又看到好多人都用c4d做出了超级好看的模型，于是乎，想先学学看这个。 ​ 虽然说以前会一点3D建模，但感觉这个软件还是得从零开始，前几天B站给我推了一个c4d的教程，看了之后发现还不错，【Mo公开课】C4D基础课! 这是链接🔗，感觉是很良心的一份视频教程了，打算寒假里有时间就看一点学一点，开学之后也可能无限期拖下去（拖延症+懒癌晚期）。 2021 2.9​ 我在三天前下好了c4d r23, 这几天囫囵吞枣地把教程前六集看了，主要想先把盆友的模型先搞定了。 ​ 教程前几天除了介绍之外，教了一些最基本的操作，最后做了一个小桌子。感觉c4d的操作逻辑还是挺好理解的，据网上说是最容易上手的3D建模软件，用起来感觉好像也比之前高中用的inventor更加顺手一点。 ​ ​ 然后就是帮朋友完成她的工程力学小模型 ​ ​ 今天又偶然看到一个油管上的c4d大佬，( / ) C4D TUTORIAL | Infinite Blooming Flower! 这个视频讲的是怎么做一朵无限生长的花，感觉还挺有意思，明天做做看。 晚安 💤 :p 2.13过年宜咕咕咕🐦 新年快乐 3.32月的后半个月过的可太开心了。前几天回学校了，终于有点心思开始做了，其实这朵花之前稍微做了一点，现在又把它稍微完善了一下。 尽管是照着做的，很多操作也没怎么搞懂，但起码还是学到挺多东西，比如动画、材质什么的。 ​"},{"title":"Hello World","date":"2021-01-28T11:43:25.000Z","path":"2021/01/28/My-First-Blog/","text":"跟着教程把这个博客搭了起来，用的是hexo，部署在github上，花八块钱注册了个域名，起飞！ 日后再慢慢完善这个博客吧 先睡了 2021/1/30 0:15"}]